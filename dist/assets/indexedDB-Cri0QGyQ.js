var g=Object.defineProperty;var h=(c,t,a)=>t in c?g(c,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[t]=a;var d=(c,t,a)=>h(c,typeof t!="symbol"?t+"":t,a);class f{constructor(){d(this,"dbName","KageDB");d(this,"version",1);d(this,"db",null)}async init(){return new Promise((t,a)=>{const e=window.indexedDB.open(this.dbName,this.version);e.onerror=()=>{console.error("IndexedDB failed to open"),a(!1)},e.onsuccess=s=>{this.db=s.target.result,t(!0)},e.onupgradeneeded=s=>{const r=s.target.result;["goals","tasks","habits","journal","calendar","settings","user","metadata"].forEach(o=>{if(!r.objectStoreNames.contains(o)){const i=r.createObjectStore(o,{keyPath:"id",autoIncrement:!0});i.createIndex("createdAt","createdAt",{unique:!1}),i.createIndex("updatedAt","updatedAt",{unique:!1})}})}})}async saveData(t,a){return this.db||await this.init(),new Promise(e=>{if(!this.db){e(!1);return}const r=this.db.transaction([t],"readwrite").objectStore(t),n=r.clear();n.onsuccess=()=>{if(Array.isArray(a))a.forEach(o=>{const i={...o,updatedAt:new Date().toISOString()};r.add(i)});else if(a&&typeof a=="object"){const o={...a,id:1,updatedAt:new Date().toISOString()};r.add(o)}e(!0)},n.onerror=()=>e(!1)})}async getData(t){return this.db||await this.init(),new Promise(a=>{if(!this.db){a([]);return}const r=this.db.transaction([t],"readonly").objectStore(t).getAll();r.onsuccess=()=>{a(r.result||[])},r.onerror=()=>a([])})}async addItem(t,a){return this.db||await this.init(),new Promise(e=>{if(!this.db){e(!1);return}const r=this.db.transaction([t],"readwrite").objectStore(t),n={...a,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()},o=r.add(n);o.onsuccess=()=>e(!0),o.onerror=()=>e(!1)})}async updateItem(t,a,e){return this.db||await this.init(),new Promise(s=>{if(!this.db){s(!1);return}const n=this.db.transaction([t],"readwrite").objectStore(t),o=n.get(a);o.onsuccess=()=>{const i=o.result;if(i){const u={...i,...e,updatedAt:new Date().toISOString()},l=n.put(u);l.onsuccess=()=>s(!0),l.onerror=()=>s(!1)}else s(!1)},o.onerror=()=>s(!1)})}async deleteItem(t,a){return this.db||await this.init(),new Promise(e=>{if(!this.db){e(!1);return}const n=this.db.transaction([t],"readwrite").objectStore(t).delete(a);n.onsuccess=()=>e(!0),n.onerror=()=>e(!1)})}async exportAllData(){const t={};try{t.goals=await this.getData("goals"),t.tasks=await this.getData("tasks"),t.habits=await this.getData("habits"),t.journal=await this.getData("journal"),t.calendar=await this.getData("calendar");const a=await this.getData("settings");t.settings=a[0]||{};const e=await this.getData("user");t.user=e[0]||{};const s=await this.getData("metadata");return t.metadata=s[0]||{},t}catch(a){return console.error("Error exporting data:",a),null}}async importAllData(t){try{return await this.saveData("goals",t.goals||[]),await this.saveData("tasks",t.tasks||[]),await this.saveData("habits",t.habits||[]),await this.saveData("journal",t.journal||[]),await this.saveData("calendar",t.calendar||[]),await this.saveData("settings",t.settings||{}),await this.saveData("user",t.user||{}),t.metadata&&Object.keys(t.metadata).length>0&&(await this.getInstallationMetadata()||await this.saveData("metadata",t.metadata)),!0}catch(a){return console.error("Error importing data:",a),!1}}async clearAllData(){this.db||await this.init();const t=["goals","tasks","habits","journal","calendar","settings","user"];try{for(const a of t)await new Promise((e,s)=>{if(!this.db){s();return}const o=this.db.transaction([a],"readwrite").objectStore(a).clear();o.onsuccess=()=>e(),o.onerror=()=>s()});return!0}catch(a){return console.error("Error clearing data:",a),!1}}async getStorageStats(){const t=["goals","tasks","habits","journal","calendar","settings","user","metadata"],a={};let e=0,s=0;for(const r of t){const n=await this.getData(r);a[r]=n.length,e+=n.length,s+=JSON.stringify(n).length}return{totalItems:e,storeStats:a,estimatedSize:s}}async getInstallationMetadata(){const t=await this.getData("metadata");return t.length>0?t[0]:null}async initializeAppMetadata(t="1.0.0"){const a=await this.getInstallationMetadata(),e=new Date().toISOString(),s=1;if(a){const r=a.appVersion!==t,n=(a.dataVersion||1)<s;return(r||n)&&(n&&(console.log(`📊 Data migration needed: v${a.dataVersion||1} → v${s}`),await this.performDataMigration(a.dataVersion||1,s)),await this.saveData("metadata",[{...a,appVersion:t,dataVersion:s,lastUpdate:e,isFirstRun:!1}])),{installationId:a.installationId,deviceId:a.deviceId,isFirstRun:!1,isUpdate:r,migrationNeeded:n}}else{const r=this.generateId(),n=this.generateDeviceId();return await this.saveData("metadata",[{installationId:r,deviceId:n,appVersion:t,dataVersion:s,firstInstall:e,lastUpdate:e,isFirstRun:!0}]),{installationId:r,deviceId:n,isFirstRun:!0,isUpdate:!1,migrationNeeded:!1}}}async performDataMigration(t,a){console.log(`🔄 Performing data migration: v${t} → v${a}`);try{const e=await this.exportAllData();e&&localStorage.setItem(`kage-migration-backup-${Date.now()}`,JSON.stringify(e));for(let s=t;s<a;s++)await this.migrateFromVersion(s);console.log("✅ Data migration completed successfully")}catch(e){throw console.error("❌ Data migration failed:",e),e}}async migrateFromVersion(t){switch(t){case 1:break;case 2:break;default:console.log(`No migration needed for version ${t}`)}}generateId(){return Date.now().toString()+Math.random().toString(36).substring(2,9)}generateDeviceId(){const t=document.createElement("canvas"),a=t.getContext("2d");a==null||a.fillText("device-fingerprint",10,10);const e=t.toDataURL(),s=[navigator.userAgent,navigator.language,screen.width+"x"+screen.height,new Date().getTimezoneOffset(),e.slice(-50)].join("|");let r=0;for(let n=0;n<s.length;n++){const o=s.charCodeAt(n);r=(r<<5)-r+o,r=r&r}return"dev_"+Math.abs(r).toString(36)}async createAutoBackup(){try{const t=await this.exportAllData();if(!t)return!1;const a=`kage-auto-backup-${Date.now()}`,e={...t,backupInfo:{createdAt:new Date().toISOString(),type:"auto",version:"1.0.0"}};return localStorage.setItem(a,JSON.stringify(e)),this.cleanupOldBackups(),console.log("💾 Auto-backup created:",a),!0}catch(t){return console.error("Failed to create auto-backup:",t),!1}}cleanupOldBackups(){try{const t=Object.keys(localStorage).filter(a=>a.startsWith("kage-auto-backup-")).sort().reverse();t.length>3&&t.slice(3).forEach(a=>{localStorage.removeItem(a),console.log("🗑️ Removed old backup:",a)})}catch(t){console.error("Failed to cleanup old backups:",t)}}async getAvailableBackups(){var a,e;const t=[];for(const s of Object.keys(localStorage))if(s.startsWith("kage-auto-backup-")||s.startsWith("kage-migration-backup-"))try{const r=localStorage.getItem(s);if(r){const n=JSON.parse(r);t.push({key:s,createdAt:((a=n.backupInfo)==null?void 0:a.createdAt)||"Unknown",type:((e=n.backupInfo)==null?void 0:e.type)||"auto",size:r.length})}}catch{console.warn("Invalid backup data for key:",s)}return t.sort((s,r)=>new Date(r.createdAt).getTime()-new Date(s.createdAt).getTime())}}const b=new f;export{b as default,b as indexedDB};
